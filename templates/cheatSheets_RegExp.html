<!--cheatSheets_RegExp.html-->
<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <title>RegExp</title>
    <link type="image/png" sizes="16x16" rel="icon" href="../images/icon.png" />

    <link rel="stylesheet" href="../style.css" />

    <script type="text/javascript" src="../js/jquery-3.6.3.min.js"></script>
    <script type="module" src="../js/main.js"></script>
  </head>
  <body>
    <header id="header" class="header"></header>
    <!-- &lt; &nbsp; &gt; -->
    <!--------------------------------------------------------------------------------------------------------------------------------------------------------------------------->
    <!-- Список -->

    <div class="fon_content">
      <div class="con_content">
        <pre>
          Регулярные выражения(RegExp)

регулярное выражение заключается в пару символов слеш: /выражение/
$ – конец строки: /hello$/ (заканчивается на hello)
или создаются с помощью конструктора:  new RegExp("hello$")
цифры и буквы – соответствуют сами себе

Unicode

\0 – символ Nul	\u0000
\t - табуляция	\u0009
\n – переход на новую строку	\u000A
\v – вертикальная табуляция	\u000B
\f – переход на новую страницу	\u000C
\r – возврат каретки	\u000D

\xnn – символы из набора Latin, задаваемый шеснадцатиричным номером nn
\unnnn – символ unicode, задаваемый шеснадцатирицным номером nnnn
\cX – управляющий символ "X", например \cJ  эквивалентна \n

Чтобы написать регулярное выражение, которое ищет обратный слеш, нужно перед ним поставить обратный слеш: /\\/

[] – можно объединять в классы: /[0123456789]/ (соответствует любой цифре)
^ – отрицание, становится внутри класса в начале: [^0123456789] (все кроме цифр)
– – диапазон: /[0-9]/ (все цифры)
[...] – любой из символов, указанных в скобках
[^...] – любой кроме символов, указанных в скобках
.(точка) – любой символ, кроме перехода строки или другого разделителя строки
\w – эквивалентно [a-zA-Z0-9_] – любой буквенно-циферный символ, включая подчеркивание
\W – эквивалентно [^a-zA-Z0-9_] – кроме любого буквенно-циферного символа, включая подчеркивание
\s – любой пробельный символ из unicode
\S – любой не пробельный символ из unicode
\d – эквивлентно [0-9] (любые цифры ASCII)
\D – эквивлентно [^0-9] (все кроме цифры ASCII)
[\b] – граница слова

пример: [\w\s] – любому пробельному символу или символу ASCII(буквы или цифры)

Квантификация – многократные повторения, заключаются в фигурные скобки и следует сразу за описанным шаблоном: {}
{n} – ровно n экземпляров шаблона
{n,} – n или больше экземпляров шаблона
{n,m} – не менее n и не более m экземпляров шаблона
? – 0 или 1 экземпляр шаблона эквивалентно {0,1}
+ – 1 или более экземпляр шаблона эквивалентно {1,}
* – 0 или более экземпляр шаблона эквивалентно {0,}

пример: /x{1,}/ – будет соответствовать всем x или xxx и тп., встреченным в тексте(жадная квантификация)
/x{1,}/? только первым x или xxx и тп., встреченным в тексте(ленивая квантификация)

| – альтернатива(или): /ma|pa|da/ (или ma или pa или da)
() – группировка: /regular(expression)?/ – соответствует слову regular, за которым следует необязательное expression
или: /123+/ – цифры 12 и за ними любое количество 3 (123, 1233, 12333, и тп.)

Якорные выражения

^ – соответствует началу строки, при многострочном поиске или началу строкового выражения
$ – соответствует концу строки, при многострочном поиске или концу строкового выражения
\b – соответствует границе слова, т.е. позиции между строковы (aA-zZ) и текстовым символом и началом или концом стоки.
\B – позиции не являются границей слов
(?=p) – позитивная опережающая проверка, проверка на последние символы – убеждаемся в том, что последующие символы соответствуют шаблону "p", но не включает их в результат поиска.
(?!p) – негативная опережающая проверка, проверка на последние символы – требует чтобы последующие символы не соответствовали шаблону "p"

Флаги – указываются после слешей

i – что поиск по шаблону  не чуствителен к риестру.
g – поиск должен быть глобальным, т.е. должны быть найдены ВСЕ соответствия в строке.
m – указывает на то, что поиск должен проводиться во многострочном режиме.

Методы

search() – в качестве аргумента передаем регулярное выражение, в ответ получаем номер строки, где оно найдено или -1, если его нет.

replace() – поиск с заменой:
replace(/is/g,"as"); -заменит все найденые is на as
replace(/is/,"as"); -заменит первую найденую is на as

match() – в качестве аргумента принимает регулярное выражение, в ответ возвращает массив совпадений.

split() – разбивает строку на массив из подстрок, используя в качестве разделителя значение аргумента.

Конструктор

new RegExp("g$"); -создаем шаблон
new RegExp("g$","g"); -создаем такой же шаблон, но добавляем флаг глобального поиска.

Свойства конструктора:
source – текст регулярного выражения
ignoreCase – наличие флага "i"
global – наличие флага "g"
multiline – наличие флага "m"
lastindex -счетчик, с какой позиции начинать поиск.

Методы объекта.

exec(text) – выполнение поиска в строке переданной в качестве аргумента, возвращает массив найденных совпадений, если их нет то null. lastindex – позиция на которой заканчивается найденный элемент в строке.

test(text) – тоже возвращает массив из совпаденний, если совпадение есть, возвращает lastindex, если нет 0. 

        </pre>
      </div>
    </div>

    <!--------------------------------------------------------------------------------------------------------------------------------------------------------------------------->
    <!-- &lt; &nbsp; &gt; -->

    <footer id="footer" class="footer"></footer>
  </body>
</html>
