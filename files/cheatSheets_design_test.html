<!--cheatSheets_design_test.html-->
<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8" />
    <link rel="stylesheet" href="../cheatSheets.css" />
    <title>cheatSheets_design_test</title>
    <link type="image/png" sizes="16x16" rel="icon" href="../images/icon.png">

    <link rel="stylesheet" href="https://unpkg.com/flexboxgrid2@7.2.1/flexboxgrid2.min.css">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <script type="text/javascript" src="../js/jquery-3.6.3.min.js"></script>
    <script type="text/javascript" src="../js/cheatSheets.js"></script>

</head>
<body>

  <!--------------------------------------------------------------------------------------------------------------------------------------------------------------------------->
  <!-- Шапка -->
   
    <header class="nav">
        <div class="con_nav">
          <nav class="home">
            <a href="../index.html"><img src="../images/home.png" width="60px" alt="home" class="logo_nav"></a><!-- Лого -->
          </nav>
          <div class="name">
            <h1>Тест дизайн</h1>
          </div>
        </div><!-- /Контейнер шапка -->
    </header><!-- /Тело шапка -->

  <!--------------------------------------------------------------------------------------------------------------------------------------------------------------------------->
  <!-- Список -->

    <div class="fon_content">
      <div class="con_content">

        <p>
          <b>Тест дизайн</b> — это этап процесса тестирования ПО, на котором 
          проектируются и создаются тестовые случаи (тест-кейсы).
          
        </p><hr>

        <h2>Техники тест дизайна :</h2>

        <h3>Эквивалентное Разделение.</h3>

        <p>
          Метод эквивалентного разделения позволяет минимизировать число тестов, не 
          создавая сценарий для каждого возможного значения, а выбрав только одно 
          значение из целого класса и приняв за аксиому, <b>что для всех значений в 
          данной группе результат будет аналогичным</b>.<br>
          Например, мы тестируем функциональность приложения, позволяющего 
          покупать авиабилеты онлайн.<br>
          Стоимость билета будет зависеть от возраста 
          пассажира, так как дети, студенты и пенсионеры относятся ко льготным 
          категориям.<br>
          У нас есть четыре возрастных группы:<br>
          младше 15 лет,<br>
          от 15 до 25 лет,<br>
          старше 25 и младше 60 лет<br>
          и люди старше 60.<br>
          При этом, в поле для ввода возраста помещается всего два символа, поэтому указать возраст более 99 лет 
          технически невозможно.<br>
          Тестировщику не нужно писать 99 тестов для каждого возраста, хватит пяти:<br> 
          по одному для каждой возрастной группы (скажем, 10, 18, 35 и 75 лет)<br>
          и один для случая, если возраст человека превышает 99 лет. Да, последний тест на 
          практике невыполним (поскольку в поле возраста невозможно ввести более 
          двух знаков), и все же не следует забывать об этой проверке.
        </p>

        <h3>Анализ граничных значений.</h3>
        
        <p>
          Техника граничных значений основана на предположении, что <b>большинство 
        ошибок может возникнуть на границах эквивалентных классов</b>. Она тесно 
        связана с вышеописанной техникой эквивалентного разделения, из-за чего 
        часто используется с ней в паре.<br>
        Тогда для примера из предыдущего пункта границами будут являться значения 0, 15, 25, 60 и 99.<br>
        Граничными значениями будут 0, 1,  14, 15, 16,  24, 25, 26,  59, 60, 61,  98, 99, 100.<br> 
        Анализ граничный значений и эквивалентное разделение может быть 
        применен к полям, записям, файлам, или к любого рода сущностям, имеющим 
        ограничения.
        </p>
        
        <h3>Предугадывание ошибки.</h3> 

        <p>
        Используя свои знания о системе, тестировщик может <b>«предугадать»</b>, при 
        каких входных условиях есть риск ошибок. Для этого важно иметь опыт, 
        хорошо знать продукт и уметь выстроить коммуникации с коллегами.<br>
        Например, в спецификации указано, что поле возраст должно принимать два символа.<br><br>

        В числе возможных тестов:<br>
        - Что произойдёт, если не ввести возраст?<br>
        - Что произойдёт, если ввести отрицательный возраст, например, - 9?<br>
        - Что произойдёт, если ввести не цифры, а другие символы?<br>
        - Что произойдёт, если ввести цифру и другой символ?<br>
        - Что произойдёт, если попытаться ввести не две цифры, а другое<br> 
        количество?<br>
        </p>
     
       <h3>Исчерпывающее тестирование.</h3> 

       <p>
        Используется крайне редких случаях. В пределах этой техники вы должны 
        <b>проверить все возможные комбинации входных значений</b>, и в результате, это 
        должно найти все проблемы. На практике применение этого метода не 
        представляется возможным, из-за огромного количества входных значений.<br>
        Тогда для примера из первого пункта будут перебираться все значения от 0 до 
        99 включительно.
       </p>
       
       <h3>Матрица соответствия требованиям.</h3>

       <p>
        <b>Матрица соответствия требованиям</b> – это двумерная таблица, содержащая 
        соответствие функциональных требований продукта и подготовленных 
        тестовых сценариев.<br>
        В заголовках строк таблицы расположены требования, а в заголовках колонок – тестовые сценарии или наоборот.<br>
        На пересечении соответствующих строки и столбца ставится отметка, обозначающая, что 
        данное требование покрывается данным тест-кейсом.
       </p>
        
       <div class="con_img">
        <img src="../images/Матрица_требований.png" class="img">
       </div>

       <p>
        Таким образом, <b>таблица дает визуальное отображение двух параметров:</b><br>
        - <b>наличие в системе требований, которые еще не покрыты</b>(если у 
        требования нет ни одного пересечения с тест-кейсами);<br>
        - есть ли в системе <b>избыточное тестирование</b> — если требования имеет 
        несколько пересечений(необходимое условие).
       </p>
        
       <h3>Попарное тестирование.</h3>

       <p>
        <b>Попарное тестирование</b> – это техника формирования наборов тестовых 
        данных из полного набора входных данных в системе, которая позволяет 
        существенно сократить количество тест-кейсов.<br>
        Сформулировать суть попарного тестирования можно следующим образом:<br> 
        формирование таких наборов данных, в которых каждое тестируемое значение 
        каждого из проверяемых параметров хотя бы единожды сочетается с каждым 
        тестируемым значением всех остальных проверяемых параметров.<br><br>
        Главные цели попарного тестирования:<br>
        - убрать избыточные проверки;<br>
        - обеспечить хорошее тестовое покрытие;<br>
        - выявить наибольшее количество багов на минимальном наборе тестов.<br><br>

        Допустим, какое-то значение (например, налог) для человека рассчитывается 
        на основании его пола, возраста и наличия детей – получаем три входных 
        параметра, для каждого из которых для тестов выбираем любое из возможных 
        значений.<br>
        Например:<br>
        пол – мужской или женский;<br>
        возраст – до 25, от 25 до 60, более 60;<br>
        наличие детей – да или нет.<br>
        Для проверки правильности расчетов 
        можно, конечно, перебрать все комбинации значений всех параметров:
       </p>

       <div class="con_img">
        <img src="../images/Попарное_тестирование1.png" class="img">
       </div>
        
       <p>
        А можно решить, что <b>не нужно проверять сочетания значений всех 
        параметров со всеми</b>, а только убедиться, что <b>проверятся все уникальные пары 
        значений параметров</b>.<br> 
        Например, с точки зрения параметров пола и возраста нужно убедиться, что точно проверим мужчину до 25, мужчину между 25 и 
        60, мужчину после 60, а также женщину до 25, женщину между 25 и 60, также женщину после 60.<br>
        И точно так же для всех остальных пар параметров.<br>
        И таким образом, можем получить гораздо меньше наборов значений:
       </p>
        
       <div class="con_img">
        <img src="../images/Попарное_тестирование2.png" class="img">
       </div>
      
      </div>
    </div>

  <!--------------------------------------------------------------------------------------------------------------------------------------------------------------------------->
  <!-- Подвал -->

    <footer class="footers">
        <div class="con_footers">
        
        <div class="footer_avtor">
            <img src="../images/signature.png" class="signature"> 
        </div>
        
       </div><!-- /Контейнер подвал -->
    </footer><!-- /Тело подвал -->

</body>
